export const promiseCath = ''

// Какой способ перехвата ошибки применим для следующего кода?
// function asyncFunc(a, b) {
//   return new Promise((resolve, reject) => {
//     if (a.name.length < b.name.length) {
//       reject();
//     } else {
//       resolve();
//     }
//   });
// }
// asyncFunc({ fullName: 'John Mistin' }, { lastName: 'Mistin' });

// a) try {} catch(err) {}
// b) then().catch() ------  !!!DONE!!!
// c) Присвоить результат выполнения в переменную и проверить функцией .isValid()
// d) Ничего из перечисленного
// e) Присвоить результат выполнения в переменную => преобразовать в Boolean => проверить на true/false


// Также важно понимать, что промис всегда возвращает промис, вне зависимости от того, произошла ошибка или нет, т.е.:

// try {
//   promise
//     .then(() => {
//       throw new Error('error');
//     })
//     .catch((error) => {
//       // выполнится
//     });
// } catch (error) {
//   // не выполнится
// }


// Таким образом, ответ a) неправильный, потому что промис не влияет на конструкцию try{} catch(){}. 
//Ответ с) неправильный, потому что у промиса нет метода isValid(). Ответ e) неправильный, 
//потому что промис всегда возвращает промис, и если объект привести к булевому значению,
// то ответ всегда будет true. И ответ d) неправильный, 
//потому что правильный ответ b), 
//так как ошибку в промисе можно перехватить или методом catch(), 
//или вторым аргументом метода then().




