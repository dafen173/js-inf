export const stateProps = ''


// например я создал банк в виде объекта с различными полями с названием адресом процентной ставкой и т.п.
// эти объекты банков надо хранить в стейте и в стейте их можно менять - добавлять, удалять, редактировать
// а вот если надо передать данные из полей объекта банк (например поле процентной ставки) в другой компонент - 
//например страница расчета кредитного калькулятора -
// то эту инф уже можно передавать через пропсы
// их менять нельзя а только можно передавать уже существующие поля из объекта банк

// state это структура данных которая имеет некоторое начальное значение и когда react
// рисует свой интерфейс то он основывается на начальном значение state и например при этом в 
//процессе работы приложения
// state может меняться и в основном он меняется из-за каких-то пользовательских действий 

//а props
// это параметры которые поступают в компонент то есть это конфигурация которая идет от родителя компонента
// props нельзя менять ну и по сути это такое однонаправленное состояние которое передается 
//по древовидной структуре

// Ключевое различие между свойствами и состоянием заключается в том, что состояние 
//является внутренним и контролируется самим компонентом, в то время как свойства являются 
//внешними и контролируются тем, что отображает компонент.

//https://hackit-ukraine.com/2864-where-to-hold-react-component-data-state-store-static-and-this
// На сьогодні найкраща практика полягає у використанні локального стану для обробки стану 
//вашого інтерфейсу користувача (UI), а не даних. Наприклад, використання контрольованого 
//компонента для заповнення форми є цілком допустимим використанням місцевого стану .
// Хороший спосіб подумати про те, коли використовувати локальний стан, - це розглянути, 
//чи використовуватиме значення, яке ви зберігаєте, інший компонент. 
//Якщо значення є специфічним лише для одного компонента (або, можливо, для одного дочірнього 
//елемента цього компонента), тоді це значення можна зберігати в локальному стані .

// Кейси використання
// Магазин Redux чудово підходить для збереження стану програми, а не стану інтерфейсу користувача. 
//Прекрасний приклад - це статус входу користувача. Багато з ваших компонентів потребуватимуть доступу 
//до цієї інформації, і як тільки статус входу зміниться, усі ці компоненти (щонайменше ті, 
//що відображаються) повинні будуть бути відтворені разом із оновленою інформацією.
// Redux також корисний для активації подій, для яких вам потрібен доступ до декількох компонентів
// або через кілька маршрутів. Прикладом цього може бути спосіб входу в систему, який може запускатися
// безліччю кнопок у всьому додатку. Замість того, щоб умовно відображати модаль у десятку місць, 
//ви можете умовно відтворити його на верхньому рівні своєї програми та використати дію Redux для 
//його запуску, змінивши значення в магазині .
// Винос : зберігайте дані, якими ви збираєтесь ділитися між компонентами, у магазині .





