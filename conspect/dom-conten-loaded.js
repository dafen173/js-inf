export const DOMContentLoaded = ''

//https://learn.javascript.ru/onload-ondomcontentloaded

// У жизненного цикла HTML-страницы есть три важных события:

// DOMContentLoaded – браузер полностью загрузил HTML, было построено DOM-дерево, но внешние ресурсы,
//такие как картинки <img> и стили, могут быть ещё не загружены.

// load – браузер загрузил HTML и внешние ресурсы (картинки, стили и т.д.).

// beforeunload/unload – пользователь покидает страницу.

// Каждое из этих событий может быть полезно:
// Событие DOMContentLoaded – DOM готов, так что обработчик может искать DOM-узлы и инициализировать интерфейс.
// Событие load – внешние ресурсы были загружены, стили применены, размеры картинок известны и т.д.
// Событие beforeunload – пользователь покидает страницу. Мы можем проверить, сохранил ли он изменения и
//спросить, на самом ли деле он хочет уйти.
// unload – пользователь почти ушёл, но мы всё ещё можем запустить некоторые операции, например, отправить
//статистику.

// DOMContentLoaded
// Событие DOMContentLoaded срабатывает на объекте document.
// Мы должны использовать addEventListener, чтобы поймать его:

// document.addEventListener("DOMContentLoaded", ready);
// // не "document.onDOMContentLoaded = ..."

// Например:
// <script>
//   function ready() {
//     alert('DOM готов');
//     // изображение ещё не загружено (если не было закешировано), так что размер будет 0x0
//     alert(`Размер изображения: ${img.offsetWidth}x${img.offsetHeight}`);
//   }
//   document.addEventListener("DOMContentLoaded", ready);
// </script>

// <img id="img" src="https://en.js.cx/clipart/train.gif?speed=1&cache=0">

// В этом примере обработчик DOMContentLoaded запустится, когда документ загрузится, так что он увидит
//все элементы, включая расположенный ниже <img>.

// Но он не дожидается, пока загрузится изображение. Поэтому alert покажет нулевой размер.

// На первый взгляд событие DOMContentLoaded очень простое. DOM-дерево готово – получаем событие.
//Хотя тут есть несколько особенностей.

// DOMContentLoaded и скрипты
// Когда браузер обрабатывает HTML-документ и встречает тег <script>, он должен выполнить его перед тем,
//как продолжить строить DOM. Это делается на случай, если скрипт захочет изменить DOM или даже дописать в 
//него (document.write), так что DOMContentLoaded должен подождать.

// Поэтому DOMContentLoaded определённо случится после таких скриптов:

// <script>
//   document.addEventListener("DOMContentLoaded", () => {
//     alert("DOM готов!");
//   });
// </script>

// <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js"></script>

// <script>
//   alert("Библиотека загружена, встроенный скрипт выполнен");
// </script>

// В примере выше мы сначала увидим «Библиотека загружена…», а затем «DOM готов!» (все скрипты выполнены).

// Скрипты, которые не блокируют DOMContentLoaded
// Есть два исключения из этого правила:

// Скрипты с атрибутом async, который мы рассмотрим немного позже, не блокируют DOMContentLoaded.
// Скрипты, сгенерированные динамически при помощи document.createElement('script') и затем добавленные 
//на страницу, также не блокируют это событие.

// DOMContentLoaded и стили
// Внешние таблицы стилей не затрагивают DOM, поэтому DOMContentLoaded их не ждёт.
// Но здесь есть подводный камень. Если после стилей у нас есть скрипт, то этот скрипт должен дождаться, 
//пока загрузятся стили:

// <link type="text/css" rel="stylesheet" href="style.css">
// <script>
//   // скрипт не выполняется, пока не загрузятся стили
//   alert(getComputedStyle(document.body).marginTop);
// </script>
// Причина в том, что скрипту может понадобиться получить координаты или другие свойства элементов, 
//зависящих от стилей, как в примере выше. Естественно, он должен дождаться, пока стили загрузятся.

// Так как DOMContentLoaded дожидается скриптов, то теперь он так же дожидается и стилей перед ними.


// Итого
// События загрузки страницы:
// DOMContentLoaded генерируется на document, когда DOM готов. Мы можем применить JavaScript к элементам 
//на данном этапе.
// Скрипты, вроде <script>...</script> или <script src="..."></script> блокируют DOMContentLoaded, 
//браузер ждёт, пока они выполнятся.
// Изображения и другие ресурсы тоже всё ещё могут продолжать загружаться.




import { contents } from "./contents"


