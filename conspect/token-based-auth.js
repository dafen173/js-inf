export const tokenBaseAauth = 'https://gist.github.com/zmts/802dc9c3510d79fd40f9dc38a12bccfc'


// Про токены, JSON Web Tokens (JWT), аутентификацию и авторизацию. Token-Based Authentication
// Last major update: 25.08.2020

// Что такое авторизация/аутентификация
// Где хранить токены
// Как ставить куки ?
// Процесс логина
// Процесс рефреш токенов
// Кража токенов/Механизм контроля токенов
// Зачем все это ? JWT vs Cookie sessions

// Основа:
// Аутентификация(authentication, от греч. αὐθεντικός [authentikos] – реальный, подлинный; 
//от αὐθέντης [authentes] – автор) - это процесс проверки учётных данных пользователя (логин/пароль). 
//Проверка подлинности пользователя путём сравнения введённого им логина/пароля с данными сохранёнными 
//в базе данных.

// Авторизация(authorization — разрешение, уполномочивание) - это проверка прав пользователя на 
//доступ к определенным ресурсам.

// Например, после аутентификации юзер sasha получает право обращаться и получать от ресурса 
//"super.com/vip" некие данные. Во время обращения юзера sasha к ресурсу vip система авторизации
// проверит имеет ли право юзер обращаться к этому ресурсу (проще говоря переходить по 
//неким разрешенным ссылкам)

// Юзер c емайлом sasha_gmail.com успешно прошел аутентификацию
// Сервер посмотрел в БД какая роль у юзера
// Сервер сгенерил юзеру токен с указанной ролью
// Юзер заходит на некий ресурс используя полученный токен
// Сервер смотрит на права(роль) юзера в токене и соответственно пропускает или отсекает запрос
// Собственно п.5 и есть процесс авторизации.

// JSON Web Token (JWT) — содержит три блока, разделенных точками: 
//заголовок(header), набор полей (payload) и сигнатуру. 

//Первые два блока представлены в JSON-формате и дополнительно закодированы в формат base64. 
//Набор полей содержит произвольные пары имя/значения, притом стандарт JWT определяет несколько 
//зарезервированных имен (iss, aud, exp и другие). Сигнатура может генерироваться при помощи и 
//симметричных алгоритмов шифрования, и асимметричных. Кроме того, существует отдельный стандарт, 
//отписывающий формат зашифрованного JWT-токена.

// Пример подписанного JWT токена (после декодирования 1 и 2 блоков):
// { alg: "HS256", typ: "JWT" }.
//{ iss: "auth.myservice.com", aud: "myservice.com", exp: 1435937883, userName: "John Smith", userRole: "Admin" }.
//S9Zs/8/uEGGTVVtLggFTizCsMtwOJnRhjaQ2BMUQhcY

// Токены предоставляют собой средство авторизации для каждого запроса от клиента к серверу. 
//Токены(и соответственно сигнатура токена) генерируются на сервере основываясь на секретном ключе 
//(который хранится на сервере) и payload'e. Токен в итоге хранится на клиенте и используется при 
//необходимости авторизации какого-либо запроса. Такое решение отлично подходит при разработке SPA.
// При попытке хакером подменить данные в header'ре или payload'е, токен станет не валидным, 
//поскольку сигнатура не будет соответствовать изначальным значениям. А возможность 
//сгенерировать новую сигнатуру у хакера отсутствует, поскольку секретный ключ для зашифровки лежит на сервере.

// Зачем все это ? JWT vs Cookie sessions
// Зачем этот весь геморой ? Почему не юзать старые добрые cookie sessions ? Чем не угодили куки ?

// Куки подвержены CSRF: https://habr.com/ru/company/oleg-bunin/blog/412855 https://www.youtube.com/watch?v=x5AuK_IbJlg
// Нативыным приложениям для сматфонов удобнее работать с токенами. Да есть хаки для работы с куки, 
//но это не нативная поддержка

// Куки в микросерисной архитектуре использовать не вариант. Напомню зачастую микросервисы раскиданы 
//на разных доменах, а куки не поддерживают кросc-доменные запросы

// В микросерисной архитектуре JWT позволяет каждому сервису независимо от сервера авторизации 
//верифицировать access токен (через публичный ключ)
// При использовании cookie sessions программист зачастую надеется на то, что предоставил фреймворк 
//и оставляет как есть
// При использовании jwt мы видим проблему с безопасностью и стараемся предусмотреть механизмы 
//контроля в случае крaжи авторизационных данных. При использовании cookie сессий программист зачастую 
//даже не задумывается что сессия может быть скомпрометирована
// На каждом запросе использование JWT избавляет бекенд от одного запроса в БД(или кеш) за данными 
//пользователя(userId, email, etc.)

// В итоге:
// access токены храним исключительно в памяти клиентского приложения. Не в глобально доступной 
//переменной аля window.accessToken а в замыкании
// refresh токен храним исключительно в httpOnly куке
// Механизмы контроля при угоне sensitive data в наличии
// Взяли лучшее из обеих технологий, максимально обезопасились от CSRF/XSS
// Добавьте в компанию ко всему CSP заголовки и SameSite=Strict флаг для кук и ждите прихода злодеев




