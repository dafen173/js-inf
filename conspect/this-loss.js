export const thisLoss = 'https://learn.javascript.ru/bind'




// Привязка контекста к функции
// При передаче методов объекта в качестве колбэков, например для setTimeout, возникает известная проблема – потеря this.

// В этой главе мы посмотрим, как её можно решить.

// Потеря «this»
// Мы уже видели примеры потери this. Как только метод передаётся отдельно от объекта – this теряется.

// Вот как это может произойти в случае с setTimeout:

// let user = {
//   firstName: "Вася",
//   sayHi() {
//     alert(`Привет, ${this.firstName}!`);
//   }
// };

// setTimeout(user.sayHi, 1000); // Привет, undefined!
// При запуске этого кода мы видим, что вызов this.firstName возвращает не «Вася», а undefined!

// Это произошло потому, что setTimeout получил функцию sayHi отдельно от объекта user (именно здесь функция и потеряла контекст). То есть последняя строка может быть переписана как:

// let f = user.sayHi;
// setTimeout(f, 1000); // контекст user потеряли
// Метод setTimeout в браузере имеет особенность: он устанавливает this=window для вызова функции (в Node.js this становится объектом таймера, но здесь это не имеет значения). Таким образом, для this.firstName он пытается получить window.firstName, которого не существует. В других подобных случаях this обычно просто становится undefined.

// Задача довольно типичная – мы хотим передать метод объекта куда-то ещё (в этом конкретном случае – в планировщик), где он будет вызван. Как бы сделать так, чтобы он вызывался в правильном контексте?

// Решение 1: сделать функцию-обёртку
// Самый простой вариант решения – это обернуть вызов в анонимную функцию, создав замыкание:

// let user = {
//   firstName: "Вася",
//   sayHi() {
//     alert(`Привет, ${this.firstName}!`);
//   }
// };

// setTimeout(function() {
//   user.sayHi(); // Привет, Вася!
// }, 1000);
// Теперь код работает корректно, так как объект user достаётся из замыкания, а затем вызывается его метод sayHi.

// То же самое, только короче:

// setTimeout(() => user.sayHi(), 1000); // Привет, Вася!
// Выглядит хорошо, но теперь в нашем коде появилась небольшая уязвимость.

// Что произойдёт, если до момента срабатывания setTimeout (ведь задержка составляет целую секунду!) в переменную user будет записано другое значение? Тогда вызов неожиданно будет совсем не тот!

// let user = {
//   firstName: "Вася",
//   sayHi() {
//     alert(`Привет, ${this.firstName}!`);
//   }
// };

// setTimeout(() => user.sayHi(), 1000);

// // ...в течение 1 секунды
// user = { sayHi() { alert("Другой пользователь в 'setTimeout'!"); } };

// // Другой пользователь в 'setTimeout'!
// Следующее решение гарантирует, что такого не случится.

// Решение 2: привязать контекст с помощью bind
// В современном JavaScript у функций есть встроенный метод bind, который позволяет зафиксировать this.

// Базовый синтаксис bind:

// // полный синтаксис будет представлен немного позже
// let boundFunc = func.bind(context);
// Результатом вызова func.bind(context) является особый «экзотический объект» (термин взят из спецификации), который вызывается как функция и прозрачно передаёт вызов в func, при этом устанавливая this=context.

// Другими словами, вызов boundFunc подобен вызову func с фиксированным this.

// Например, здесь funcUser передаёт вызов в func, фиксируя this=user:

// let user = {
//   firstName: "Вася"
// };

// function func() {
//   alert(this.firstName);
// }

// let funcUser = func.bind(user);
// funcUser(); // Вася
// Здесь func.bind(user) – это «связанный вариант» func, с фиксированным this=user.

// Все аргументы передаются исходному методу func как есть, например:

// let user = {
//   firstName: "Вася"
// };

// function func(phrase) {
//   alert(phrase + ', ' + this.firstName);
// }

// // привязка this к user
// let funcUser = func.bind(user);

// funcUser("Привет"); // Привет, Вася (аргумент "Привет" передан, при этом this = user)
// Теперь давайте попробуем с методом объекта:

// let user = {
//   firstName: "Вася",
//   sayHi() {
//     alert(`Привет, ${this.firstName}!`);
//   }
// };

// let sayHi = user.sayHi.bind(user); // (*)

// sayHi(); // Привет, Вася!

// setTimeout(sayHi, 1000); // Привет, Вася!
// В строке (*) мы берём метод user.sayHi и привязываем его к user. Теперь sayHi – это «связанная» функция, которая может быть вызвана отдельно или передана в setTimeout (контекст всегда будет правильным).

// Здесь мы можем увидеть, что bind исправляет только this, а аргументы передаются как есть:

// let user = {
//   firstName: "Вася",
//   say(phrase) {
//     alert(`${phrase}, ${this.firstName}!`);
//   }
// };

// let say = user.say.bind(user);

// say("Привет"); // Привет, Вася (аргумент "Привет" передан в функцию "say")
// say("Пока"); // Пока, Вася (аргумент "Пока" передан в функцию "say")
// Удобный метод: bindAll
// Если у объекта много методов и мы планируем их активно передавать, то можно привязать контекст для них всех в цикле:

// for (let key in user) {
//   if (typeof user[key] == 'function') {
//     user[key] = user[key].bind(user);
//   }
// }
// Некоторые JS-библиотеки предоставляют встроенные функции для удобной массовой привязки контекста, например _.bindAll(obj) в lodash.









